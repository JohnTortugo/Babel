Program Units (declaration + body) (usually having an extension .ads for a spec or .adb for a body)
	-> Subprograms
		-> Procedures
		-> Functions
	-> Packages



Compiling and Running Ada Programs in Linux
--------------------------------------------

This chapter describes first the gnatmake tool (Building with gnatmake), which
automatically determines the set of sources needed by an Ada compilation unit
and executes the necessary (re)compilations, binding and linking. It also
explains how to use each tool individually: the compiler (gcc, see Compiling
with gcc), binder (gnatbind, see Binding with gnatbind), and linker (gnatlink,
see Linking with gnatlink) to build executable programs. Finally, this chapter
provides examples of how to make use of the general GNU make mechanism in a
GNAT context (see Using the GNU make Utility).


gnatmake automatically takes care of the third and fourth steps (compile
changed sources and dependencies, rebind and link them) of this process. It
determines which sources need to be compiled, compiles them, and binds and
links the resulting object files.

The usual form of the gnatmake command is:

$ gnatmake [<switches>] <file_name> [<file_names>] [<mode_switches>]

The only required argument is one file_name, which specifies a compilation unit that is a main program.
If you are using standard file extensions (.adb and .ads), then the extension may be omitted from the file_name arguments.

First a definition: an object file is considered up to date if the corresponding ALI file exists and if all the source files listed in the dependency section of this ALI file have time stamps matching those in the ALI file. This means that neither the source file itself nor any files that it depends on have been modified, and hence there is no need to recompile this file.

Using GCC:

The first step in creating an executable program is to compile the units of the program using the gcc command.

The basic command for compiling a file containing an Ada unit is:

$ gcc -c [switches] <file name>


This chapter describes the GNAT binder, gnatbind, which is used to bind compiled GNAT objects.

	Checks that a program is consistent, in accordance with the rules in Chapter 10 of the Ada Reference Manual.
	Generates a main program incorporating the given elaboration order.
	Determines the set of object files required by the given main program.


$ gnatbind [`switches`] `mainprog`[.ali] [`switches`]

where mainprog.adb is the Ada file containing the main program unit body. gnatbind constructs an Ada package in two files whose names are b~mainprog.ads, and b~mainprog.adb. For example, if given the parameter hello.ali, for a main program contained in file hello.adb, the binder output files would be b~hello.ads and b~hello.adb.

The effect of this consistency checking, which includes source files, is that the binder ensures that the program is consistent with the latest version of the source files that can be located at bind time. Editing a source file without compiling files that depend on the source file cause error messages to be generated by the binder.



The "main" must be a library unit procedure with no parameters. 
You put most of your code in packages, in files like this_package.ads, 
this_package.adb, that_package.ads, that_package.adb.  Then you have 
a main procedure (not a package), perhaps program.adb.  This procedure with's 
one or more packages and calls things in them. 

Then you say: 

    gnatmake -gnata -gnato -g -O0 program.adb 

and it will invoke gcc and gnatbind automatically. 

The switches "-gnata -gnato -g -O0" are good for debugging builds. 
You can look up what they mean, if you like. 

You can put all your code in program.adb, but that doesn't scale 
well.  Sooner or later you're going to want separate library 
packages.









----------------

Ada as a language permits a great deal of freedom, but some consistency of
capitalization and indentation are helpful for reading later. The style used in
this tutorial is the style suggested in the Software Productivity Consortia's
(SPC) Ada Quality and Style: A Guide to Professional Programmers (which is the
recommended style guide by the Ada Joint Program Office). In this style
keywords are in lower case, identifiers have initial capitals, and there is at
most one statement per line. If an identifier has more than one word in it,
each word should have an initial capital letter and the words should have
underscores (``_'') between them.

To make long numbers easier to read, underscores are permitted inside a numeric
literal. For example, "1_000_000" is legal. This is similar to the way commas
are used in the United States and periods are used in Europe. Underscores
aren't allowed to be consecutive, numbers may not end in an underscore, and
underscores don't change the value of a number.


A useful Ada capability is its ability to write out literals in other bases
from 2 to 16 (C has this capability to a lessor extent as well). These are
called, reasonably enough, based literals. To create a based literal, write out
the desired base, a "#" sign, the number in the requested base, and another "#"
sign. For example, "2#1001_1000#" is a base 2 number equal to 128+16+8 = 152.

To include a double quote character in a string, type it twice ("") inside the
larger string. Thus "Hello" is a string, as is "She said, ""How are you?""". 

We'll find out later how to represent control characters, but for now we'll
note that C-like escape characters do not work. You can do the same thing in
Ada but in a different way, and because of the way Ada works they aren't used
as often.

Ada guarantees that an Integer can store numbers between -32767 and 32767
(inclusive); an Integer is likely to have a wider range. In other words, an
Integer type must use at least 16 bits, but the actual number of bits used will
depend on the compiler and machine.

A key difference between Ada and some other languages (such as C and C++) is
what happens when an evaluation cannot be completed. If a division by zero is
attempted, or an expression result is too large, Ada will normally raise an
exception. Exceptions can be handled, but if they aren't, the program will halt
(with some debugging output to help identify the kind and location of the
problem). This means that instead of silently giving wrong answers, Ada
programs normally will halt when a computation cannot be completed. This
simplifies debugging.

Unlike C or C++, but like Pascal and many other languages, Integers are not
considered the same as True or False.

The main difference between a procedure and function is that a function returns
a value, while a procedure does not (though a procedure can change the values
of parameters sent to it).


Data Types
--------------

Ada insists that types be correct in operations, and there aren't any
predefined operations for mixing Integer and Float using +, -, *, or /. Thus,
if you're using an Integer and Float together, put a function called `Float()'
around the Integer variables to cause them to be converted into floating-point
values. This makes it clear when such conversions are taking place, which is
sometimes important in understanding what a program is doing. Also, whenever
you set a Float to a constant, the constant must be written with a period in
it, or the compiler will complain.


Normally Ada will evaluate these expressions in whatever order is most
efficient for the machine. If it's important to evaluate them in a certain
order and to stop evaluating them when the answer is known, there are versions
of `and' and `or' that are called `short-circuit operations'. These operations
will execute strictly left-to-right and will not execute anything if they don't
have to. C's && and || operations work this way. The short-circuit version of
`and' is `and then'; the short-circuit version of `or' is `or else'.

One very important difference between Ada and some other languages is that Ada
considers types different even if they happen to be implemented the same way at
a particular time.

Here's an example of a new type named Column which can only have integer values
in the range 1 through 72, and another type called Row that has values 1
through 24:

 type Column is range 1 .. 72;
 type Row    is range 1 .. 24;

Ada array indices are not required to start at zero or one. Array indices can
begin (and end) with any discrete value - whatever makes the most sense for the
data. This means that you can start arrays at -5 (if that makes sense), and you
can use enumerated values as indices as well. Ada programs usually use a
starting index of 1 if there's no particularly natural starting point;


Strings
------------------------------

if you pass in a string slice as an input parameter to a subprogram, the receiving subprogram will receive the slice's index values.

Ada 95 provides a number of different ``string'' types, each best for a certain purpose.

String
This is the basic Ada String type, and is also called a ``fixed length string''. This type (String) is simply an array of Characters.

Bounded_String
Values of this type can vary in length up to a maximum length (which you supply).

Unbounded_String
Values of this type can vary in length up to the largest value of type `Natural' (usually that's over 2 billion characters).

Ada 95 includes some types that represent strings from other languages, namely C, COBOL, and Fortran.


Once you have a string, you can use predefined Ada operations on arrays (since a string is simply an array of characters).

	- Any attempt to read or write a nonexistent index position will cause the exception Constraint_Error to be raised.
	- You can read or overwrite a slice (i.e., a substring). the source and destinations must have the same length.
	- You can assign a whole string from one String to another the same way as any other variable, as long as their lengths are equal
	- You can concatenate (combine) strings together using the "&" operator.



Types
=======================

Four principles govern the type system:

Strong typing: types are incompatible with one another, so it is not possible to mix apples and oranges. There are, however, ways to convert between types.
Static typing: type checked while compiling, this allows type errors to be found earlier.
Abstraction: types represent the real world or the problem at hand; not how the computer represents the data internally. There are ways to specify exactly how a type must be represented at the bit level, but we will defer that discussion to another chapter.
Name equivalence, as opposed to structural equivalence used in most other languages. Two types are compatible if and only if they have the same name; not if they just happen to have the same size or bit representation. You can thus declare two integer types with the same ranges that are totally incompatible, or two record types with exactly the same components, but which are incompatible.

Types are incompatible with one another. However, each type can have any number of subtypes, which are compatible with their base type and may be compatible with one another. 

The primitive types are: Integer (Natural, Positve), Float, Duration, Character, String, Boolean and others.


You can define a new type with the following syntax:

type T is...

type Integer_1 is range 1 .. 10;
type Integer_2 is range 1 .. 10;

A derived type is a new, full-blown type created from an existing one. Like any other type, it is incompatible with its parent; however, it inherits the primitive operations defined for the parent type.

type Integer_2 is new Integer_1 range 2 .. 8;
A : Integer_1 := 8;
B : Integer_2 := A; -- illegal!



Ada allows memory to be allocated dynamically like this:

    X := new Appointment_Type;  -- create a new Appointment_Type record

New takes a free block of memory from a storage pool of available memory (often referred to as a heap) and reserves it for use as an Appointment_Type variable. A reference to its location is then assigned to the variable X so that we then have some way of accessing it. An initial value can be specified for the new appointment like this, assuming that the full declaration of Appointment_Type from the previous chapter is visible:

    X := new Appointment_Type'(Time => Time(1999,Dec,25,10,00),
                               Details => "Open presents ",
                               Length => 13);

Having set X to point to a dynamically allocated Appointment_Type variable, you can then use ‘X.all’ to access the appointment itself. You can then select components of the appointment in the usual way:

    X.all.Time := Time(1995,Dec,25,21,00);		-- you can also ommit ".all."
    if Month(X.all.Time) = Jan then ...

Be careful not to confuse ‘X’ and ‘X.all’; ‘X’ on its own is the name of the access variable, but ‘X.all’ is the value that X points to:

    X.all := Y.all;            -- copy one appointment into another
    X     := Y;                -- set X to point to the same thing as Y
Assuming that X and Y point to different appointments, the first assignment will copy the contents of one appointment into the other so that you end up with two identical appointments. In the second case X and Y will both end up pointing to the same appointment, and the appointment that X pointed to before is now inaccessible unless there’s another access variable which points to it. After the first assignment, you can alter X.Date and it won’t affect Y.Date since X and Y point to different appointments, but after the second assignment X.Date and Y.Date both refer to the same thing, so any change to X.Date will also be a change to Y.Date.

Apart from assigning a value generated by new to X, you can assign the special value null to X to indicate that it doesn’t point to anything (a ‘null pointer’). Access variables are automatically set to null when they are declared unless new is used to initialise them.
Attempting to access the value that a null pointer points to will generate a constraint error.


A record is a composite type that groups one or more fields. A field can be of any type, even a record.
 Another_Basic_Record : Basic_Record         := (A => 42);

Record (struct, class, RECORD OF) 
A record is a composite type that groups one or more fields.

Access (*, ^, POINTER TO) 
Ada's Access types may be more than just a simple memory address.





References
=======================

Types: https://en.wikibooks.org/wiki/Ada_Programming/Type_System

Access Types and Storage Allocation: http://www.adaic.org/resources/add_content/docs/craft/html/ch11.htm

GNAT Users Guide: https://docs.adacore.com/gnat_ugn-docs/html/gnat_ugn/gnat_ugn.html
